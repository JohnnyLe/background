 _                _                                   _    _
| |__   __ _  ___| | ____ _ _ __ ___  _   _ _ __   __| |  (_)___
| '_ \ / _` |/ __| |/ / _` | '__/ _ \| | | | '_ \ / _` |  | / __|
| |_) | (_| | (__|   < (_| | | | (_) | |_| | | | | (_| |_ | \__ \
|_.__/ \__,_|\___|_|\_\__, |_|  \___/ \__,_|_| |_|\__,_(_)/ |___/
                      |___/                             |__/


Background.js provides a background job queue and list with array iterators for Javascript applications.

You can get the library here:
  - Development version: https://github.com/kmalakoff/background/raw/master/background.js
  - Production version: https://github.com/kmalakoff/background/raw/master/background.min.js

The library is composed of the following classes:

  1) BGJobQueue - a sequentially-processed background job queue. When you 'push' a job on a queue, it is run on each 'tick' until it signals it is finished then the job that was added immediately after is run on the next 'tick' until it has completed...and so on.

  2) BGJobList - a sequentially-processed background job list. When you 'append' a job on a list, it and the rest of the jobs in the list are run on each 'tick' in the order they were appended until they signal that they are done.

  3) BGArrayIterator - a helper to iterate over a subset of an array on each 'tick'. You can either process the subset per iteration:
    a) callback per array item - by calling 'nextByItem' with a function of the form: (item) -> do_something
    b) callback per array slice - by calling 'nextBySlice' with a function of the form: (slice) -> do_something
    c) callback per range  (of type BGRange)- by calling 'nextByRange' with a function of the form: (range) -> do_something
    d) manually using step() which returns a range (of type BGRange) and isDone() after manually processing the range

  4) BGRange - a single array range iterator which is used per iteration to access array items. Public interfaces:
    - isDone(): returns boolean indicating whether the iteration is complete or you need to keep calling step()
    - step(): keeps stepping through indices until done
    - getItem(array): used to get the item that the range iterator is currently referring to
    - getSlice(array): used to get all the items that the range is referring to

  5) BGArrayIterator_xN - a helper to iterate over a collection of arrays on each 'tick'. It is used to iterate through all combinations between the given arrays in equal steps on each tick; for example, you can apply M transformations to each of N elements giving N*M operations in arbitrary equal sized batches per tick. You can either process the subset per iteration:
    a) callback per array item - by calling 'nextByItems' with a function of the form: (items_array) -> do_something
    b) callback per array combinations - by calling 'nextByCombinations' with a function of the form: (combinations) -> do_something
    c) callback per range (of type BGRange_xN) - by calling 'nextByRange' with a function of the form: (range) -> do_something
    d) manually using step() which returns a range (of type BGRange_xN) and isDone() after manually processing the range

  6) BGRange_xN - a multiple array range iterator which is used per iteration to access array items. Public interfaces:
  - isDone(): returns boolean indicating whether the iteration is complete or you need to keep calling step()
  - step(): keeps stepping through indices until done
  - getItems(arrays): used to get the items that all of the range iterators are currently referring to
  - getCombinations(arrays): used to get all the pair combinations of the arrays items that the range is referring to

  7) BGJob - a job class which requires a run_fn and can optionally be provided an init_fn and/or a destroy_fn.

Other notes:

  1) You can manually call 'tick' instead of waiting for the background timer.
  2) You can 'destroy' a job queue or list and it will cancel all of the jobs, and will mark it as destroyed.
  3) You can 'clear' a job queue or list and it will cancel all of the jobs.
  4) You can 'push' or 'append' a job without using the BGJob class by just passing the functions directly. In other words,
    'my_list.append(null, ->)' is equivalent to 'my_list.append(new BGJob(null, ->))'.

Please look at the provided examples and specs for sample code:
  - https://github.com/kmalakoff/background/blob/master/examples/src/example_queue.coffee
  - https://github.com/kmalakoff/background/blob/master/examples/src/example_list.coffee
  - https://github.com/kmalakoff/background/blob/master/spec


***********************************************************
This library was originally based on the following project: https://github.com/infojunkie/JobQueue with the following enhancements:

1) Allow the caller to provide set up and clean up functions:

  a) Job without setup and cleanup:
    job_queue = new BGJobQueue(10) # timeslice of 10ms per iteration
    job_queue.push(
      null,
      (->
        return true # done
      )
    )

  b) Job with setup and cleanup:
    some_var = false
    job_queue = new BGJobQueue(10) # timeslice of 10ms per iteration
    job_queue.push(
      (->some_var=1),
      (->
        return true # done
      ),
      ((was_completed)->some_var=true)
    )

2) The addition of an array iterator

  a) Iterate by array item per timeslice

    some_data = [1, 2, 3, 4]
    iterator = null
    job_queue = new BGJobQueue(10) # timeslice of 10ms per iteration
    job_queue.push(
      (->
        iterator = new BGArrayIterator(some_data, 2)     # process 2 items per job timeslice
      ),
      (-> return iterator.nextByItem((item) ->) ),
    )

    a) Iterate by array slice per timeslice
    some_data = [1, 2, 3, 4]
    iterator = null
    job_queue = new BGJobQueue(10) # timeslice of 10ms per iteration
    job_queue.push(
      (->
        iterator = new BGArrayIterator(some_data, 2)     # process 2 items per job timeslice
      ),
      (-> return iterator.nextBySlice((items) ->) ),
    )

3) Allow the caller to destroy the queue (for example, if you have a single page app)
  was_destroyed = false
  job_queue = new BGJobQueue(10) # timeslice of 10ms per iteration
  job_queue.push(
    null,
    (->
      return false # not done
    ),
    ((was_completed)->was_destroyed=(was_completed==false))
  )
  job_queue.destroy(); job_queue = null
